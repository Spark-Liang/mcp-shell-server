{
  "tasks": [
    {
      "id": "0ea5e298-4b79-47ae-ac6b-45b8d994d097",
      "name": "增强BackgroundProcess类的Process兼容性",
      "description": "修改BackgroundProcess类，使其能够与asyncio.subprocess.Process接口兼容，以便shell_executor.py可以将BackgroundProcess对象当作Process对象使用。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-05-12T08:18:34.313Z",
      "updatedAt": "2025-05-12T08:18:34.313Z",
      "relatedFiles": [
        {
          "path": "src/mcp_shell_server/backgroud_process_manager.py",
          "type": "TO_MODIFY",
          "description": "修改BackgroundProcess类，添加__getattr__方法和直接属性访问"
        }
      ],
      "implementationGuide": "1. 添加`__getattr__`方法，将未处理的属性和方法请求转发到内部的process对象：\n```python\ndef __getattr__(self, name):\n    \"\"\"转发未定义的属性和方法到内部process对象\"\"\"\n    return getattr(self.process, name)\n```\n\n2. 添加直接属性访问方法，确保关键属性如returncode、pid等可以直接从BackgroundProcess对象访问：\n```python\n@property\ndef returncode(self):\n    \"\"\"获取进程返回码\"\"\"\n    return self.process.returncode if self.process else self.exit_code\n    \n@property\ndef pid(self):\n    \"\"\"获取进程ID\"\"\"\n    return self.process.pid if self.process else None\n```\n\n3. 确保不破坏现有功能，特别是is_running方法和其他状态管理功能。",
      "verificationCriteria": "1. BackgroundProcess对象可以像Process对象一样被访问和使用\n2. 可以直接访问BackgroundProcess的returncode、pid等属性\n3. 不影响现有的BackgroundProcess功能\n4. 所有相关测试用例通过",
      "analysisResult": "## 技术分析\n\n### 现有代码分析\n\n1. **ProcessManager类分析**：\n   - `create_process` 方法：创建异步子进程，接受shell命令、工作目录、标准输入输出、环境变量等参数\n   - `execute_with_timeout` 方法：执行进程并支持超时，返回stdout和stderr\n   - 这些是shell_executor.py依赖的核心接口\n\n2. **BackgroundProcess类分析**：\n   - 当前是独立类，不是Process的子类或封装\n   - 包含对真实asyncio.subprocess.Process的引用\n   - 提供了丰富的日志记录和进程状态管理功能\n\n3. **BackgroundProcessManager类分析**：\n   - 具有自己的进程创建和管理方法\n   - 提供了额外的功能，如进程监控、输出记录等\n   - 缺少与ProcessManager完全兼容的方法签名\n\n4. **依赖分析**：\n   - bg_tool_handlers.py和backgroud_process_manager_web.py依赖BackgroundProcessManager的现有功能\n   - 重构不能破坏这些依赖关系\n\n### 实现策略\n\n1. **BackgroundProcess类增强**：\n   - 添加`__getattr__`方法：将未处理的属性和方法转发到内部process对象\n   - 实现`communicate`方法：与Process.communicate接口兼容，同时保持日志记录功能\n   - 实现或转发其他关键方法：`wait`、`terminate`、`kill`等\n   - 确保关键属性可访问：`returncode`、`pid`、`stdin/stdout/stderr`等\n\n2. **BackgroundProcessManager类增强**：\n   - 实现兼容的`create_process`方法：与ProcessManager相同的签名，内部调用现有功能\n   - 实现`execute_with_timeout`方法：处理进程执行和超时管理，复用现有功能\n   - 保持现有方法不变：确保与现有调用者兼容\n\n重构完成后，shell_executor.py应能通过不修改代码直接使用BackgroundProcessManager替代ProcessManager。"
    },
    {
      "id": "fbc88caa-33cc-47c5-a491-09afb5b47f38",
      "name": "实现BackgroundProcess.communicate方法",
      "description": "在BackgroundProcess类中实现communicate方法，使其与asyncio.subprocess.Process的communicate方法兼容，同时保持现有的日志记录功能。",
      "status": "待處理",
      "dependencies": [
        {
          "taskId": "0ea5e298-4b79-47ae-ac6b-45b8d994d097"
        }
      ],
      "createdAt": "2025-05-12T08:18:34.313Z",
      "updatedAt": "2025-05-12T08:18:34.313Z",
      "relatedFiles": [
        {
          "path": "src/mcp_shell_server/backgroud_process_manager.py",
          "type": "TO_MODIFY",
          "description": "在BackgroundProcess类中添加communicate方法"
        }
      ],
      "implementationGuide": "1. 实现communicate方法，接受与Process.communicate相同的参数：\n```python\nasync def communicate(self, input=None):\n    \"\"\"与进程通信并返回stdout和stderr\n    \n    Args:\n        input: 发送给进程的输入数据\n        \n    Returns:\n        Tuple[bytes, bytes]: 标准输出和标准错误输出\n    \"\"\"\n    if not self.process:\n        return b\"\", b\"\"\n        \n    # 调用原始进程的communicate方法\n    stdout, stderr = await self.process.communicate(input=input)\n    \n    # 如果有输出，记录到日志\n    if stdout:\n        self.add_output(stdout.decode(self.encoding, errors='replace'))\n    if stderr:\n        self.add_error(stderr.decode(self.encoding, errors='replace'))\n    \n    return stdout, stderr\n```\n\n2. 处理异常情况，特别是：\n   - 如果进程不存在\n   - 超时处理\n   - 输入输出的编码处理",
      "verificationCriteria": "1. communicate方法能接收输入并返回(stdout, stderr)元组\n2. 输出被正确记录到BackgroundProcess的日志系统\n3. 处理空数据和异常情况\n4. 相关测试用例通过",
      "analysisResult": "## 技术分析\n\n### 现有代码分析\n\n1. **ProcessManager类分析**：\n   - `create_process` 方法：创建异步子进程，接受shell命令、工作目录、标准输入输出、环境变量等参数\n   - `execute_with_timeout` 方法：执行进程并支持超时，返回stdout和stderr\n   - 这些是shell_executor.py依赖的核心接口\n\n2. **BackgroundProcess类分析**：\n   - 当前是独立类，不是Process的子类或封装\n   - 包含对真实asyncio.subprocess.Process的引用\n   - 提供了丰富的日志记录和进程状态管理功能\n\n3. **BackgroundProcessManager类分析**：\n   - 具有自己的进程创建和管理方法\n   - 提供了额外的功能，如进程监控、输出记录等\n   - 缺少与ProcessManager完全兼容的方法签名\n\n4. **依赖分析**：\n   - bg_tool_handlers.py和backgroud_process_manager_web.py依赖BackgroundProcessManager的现有功能\n   - 重构不能破坏这些依赖关系\n\n### 实现策略\n\n1. **BackgroundProcess类增强**：\n   - 添加`__getattr__`方法：将未处理的属性和方法转发到内部process对象\n   - 实现`communicate`方法：与Process.communicate接口兼容，同时保持日志记录功能\n   - 实现或转发其他关键方法：`wait`、`terminate`、`kill`等\n   - 确保关键属性可访问：`returncode`、`pid`、`stdin/stdout/stderr`等\n\n2. **BackgroundProcessManager类增强**：\n   - 实现兼容的`create_process`方法：与ProcessManager相同的签名，内部调用现有功能\n   - 实现`execute_with_timeout`方法：处理进程执行和超时管理，复用现有功能\n   - 保持现有方法不变：确保与现有调用者兼容\n\n重构完成后，shell_executor.py应能通过不修改代码直接使用BackgroundProcessManager替代ProcessManager。"
    },
    {
      "id": "31fdf49a-b0d4-4304-8921-9183722c7ba4",
      "name": "实现BackgroundProcessManager.create_process方法",
      "description": "在BackgroundProcessManager类中实现与ProcessManager兼容的create_process方法，使其返回BackgroundProcess对象，同时保持与shell_executor.py的兼容性。",
      "status": "待處理",
      "dependencies": [
        {
          "taskId": "0ea5e298-4b79-47ae-ac6b-45b8d994d097"
        }
      ],
      "createdAt": "2025-05-12T08:18:34.313Z",
      "updatedAt": "2025-05-12T08:18:34.313Z",
      "relatedFiles": [
        {
          "path": "src/mcp_shell_server/backgroud_process_manager.py",
          "type": "TO_MODIFY",
          "description": "在BackgroundProcessManager类中添加create_process方法"
        }
      ],
      "implementationGuide": "1. 实现create_process方法，保持与ProcessManager中相同的签名：\n```python\nasync def create_process(\n    self,\n    shell_cmd: str,\n    directory: Optional[str],\n    stdin: Optional[str] = None,\n    stdout_handle: Any = asyncio.subprocess.PIPE,\n    envs: Optional[Dict[str, str]] = None,\n    timeout: Optional[int] = None,\n) -> BackgroundProcess:\n    \"\"\"创建一个新的子进程，与ProcessManager.create_process兼容\n    \n    Args:\n        shell_cmd: 要执行的shell命令\n        directory: 工作目录\n        stdin: 标准输入\n        stdout_handle: 标准输出处理方式\n        envs: 额外的环境变量\n        timeout: 超时时间（秒）\n        \n    Returns:\n        BackgroundProcess: 创建的后台进程对象\n    \"\"\"\n    # 生成默认描述\n    description = f\"Shell command: {shell_cmd}\"\n    \n    # 创建BackgroundProcess对象\n    return await self.create_process(\n        command=shell_cmd,\n        directory=directory,\n        description=description, \n        stdin=stdin,\n        envs=envs,\n        timeout=timeout,\n    )\n```\n\n2. 确保参数处理与ProcessManager一致\n3. 确保返回的BackgroundProcess对象能够兼容Process接口",
      "verificationCriteria": "1. create_process方法能接受与ProcessManager.create_process相同的参数\n2. 返回的BackgroundProcess对象能被shell_executor.py使用\n3. 所有相关测试用例通过",
      "analysisResult": "## 技术分析\n\n### 现有代码分析\n\n1. **ProcessManager类分析**：\n   - `create_process` 方法：创建异步子进程，接受shell命令、工作目录、标准输入输出、环境变量等参数\n   - `execute_with_timeout` 方法：执行进程并支持超时，返回stdout和stderr\n   - 这些是shell_executor.py依赖的核心接口\n\n2. **BackgroundProcess类分析**：\n   - 当前是独立类，不是Process的子类或封装\n   - 包含对真实asyncio.subprocess.Process的引用\n   - 提供了丰富的日志记录和进程状态管理功能\n\n3. **BackgroundProcessManager类分析**：\n   - 具有自己的进程创建和管理方法\n   - 提供了额外的功能，如进程监控、输出记录等\n   - 缺少与ProcessManager完全兼容的方法签名\n\n4. **依赖分析**：\n   - bg_tool_handlers.py和backgroud_process_manager_web.py依赖BackgroundProcessManager的现有功能\n   - 重构不能破坏这些依赖关系\n\n### 实现策略\n\n1. **BackgroundProcess类增强**：\n   - 添加`__getattr__`方法：将未处理的属性和方法转发到内部process对象\n   - 实现`communicate`方法：与Process.communicate接口兼容，同时保持日志记录功能\n   - 实现或转发其他关键方法：`wait`、`terminate`、`kill`等\n   - 确保关键属性可访问：`returncode`、`pid`、`stdin/stdout/stderr`等\n\n2. **BackgroundProcessManager类增强**：\n   - 实现兼容的`create_process`方法：与ProcessManager相同的签名，内部调用现有功能\n   - 实现`execute_with_timeout`方法：处理进程执行和超时管理，复用现有功能\n   - 保持现有方法不变：确保与现有调用者兼容\n\n重构完成后，shell_executor.py应能通过不修改代码直接使用BackgroundProcessManager替代ProcessManager。"
    },
    {
      "id": "52c19588-ffbd-4327-bcb3-ff367cf3923d",
      "name": "实现BackgroundProcessManager.execute_with_timeout方法",
      "description": "在BackgroundProcessManager类中实现execute_with_timeout方法，与ProcessManager.execute_with_timeout兼容，用于执行进程并支持超时。",
      "status": "待處理",
      "dependencies": [
        {
          "taskId": "fbc88caa-33cc-47c5-a491-09afb5b47f38"
        }
      ],
      "createdAt": "2025-05-12T08:18:34.313Z",
      "updatedAt": "2025-05-12T08:18:34.313Z",
      "relatedFiles": [
        {
          "path": "src/mcp_shell_server/backgroud_process_manager.py",
          "type": "TO_MODIFY",
          "description": "在BackgroundProcessManager类中添加execute_with_timeout方法"
        }
      ],
      "implementationGuide": "1. 实现execute_with_timeout方法，保持与ProcessManager中相同的签名：\n```python\nasync def execute_with_timeout(\n    self,\n    process: Union[asyncio.subprocess.Process, BackgroundProcess],\n    stdin: Optional[bytes] = None,\n    timeout: Optional[int] = None,\n) -> Tuple[bytes, bytes]:\n    \"\"\"执行进程并支持超时，与ProcessManager.execute_with_timeout兼容\n    \n    Args:\n        process: 要执行的进程对象\n        stdin: 发送给进程的输入数据\n        timeout: 超时时间（秒）\n        \n    Returns:\n        Tuple[bytes, bytes]: (stdout, stderr)\n        \n    Raises:\n        asyncio.TimeoutError: 如果执行超时\n    \"\"\"\n    # 检查process类型\n    if isinstance(process, BackgroundProcess):\n        # 如果是BackgroundProcess，直接使用其communicate方法\n        return await process.communicate(input=stdin)\n    else:\n        # 如果是普通Process，使用普通的超时执行逻辑\n        async def _kill_process():\n            if process.returncode is not None:\n                return\n\n            try:\n                # 先尝试优雅终止\n                process.terminate()\n                for _ in range(5):  # 最多等待0.5秒\n                    if process.returncode is not None:\n                        return\n                    await asyncio.sleep(0.1)\n\n                # 如果仍在运行，强制杀死\n                if process.returncode is None:\n                    process.kill()\n                    await asyncio.wait_for(process.wait(), timeout=1.0)\n            except Exception as e:\n                logging.warning(f\"Error killing process: {e}\")\n\n        try:\n            if timeout:\n                try:\n                    return await asyncio.wait_for(\n                        process.communicate(input=stdin), timeout=timeout\n                    )\n                except asyncio.TimeoutError:\n                    await _kill_process()\n                    raise\n            return await process.communicate(input=stdin)\n        except Exception as e:\n            await _kill_process()\n            raise e\n```\n\n2. 支持处理普通Process对象和BackgroundProcess对象\n3. 正确处理超时和异常情况",
      "verificationCriteria": "1. execute_with_timeout方法能接受Process对象和BackgroundProcess对象\n2. 正确处理超时情况\n3. 所有相关测试用例通过",
      "analysisResult": "## 技术分析\n\n### 现有代码分析\n\n1. **ProcessManager类分析**：\n   - `create_process` 方法：创建异步子进程，接受shell命令、工作目录、标准输入输出、环境变量等参数\n   - `execute_with_timeout` 方法：执行进程并支持超时，返回stdout和stderr\n   - 这些是shell_executor.py依赖的核心接口\n\n2. **BackgroundProcess类分析**：\n   - 当前是独立类，不是Process的子类或封装\n   - 包含对真实asyncio.subprocess.Process的引用\n   - 提供了丰富的日志记录和进程状态管理功能\n\n3. **BackgroundProcessManager类分析**：\n   - 具有自己的进程创建和管理方法\n   - 提供了额外的功能，如进程监控、输出记录等\n   - 缺少与ProcessManager完全兼容的方法签名\n\n4. **依赖分析**：\n   - bg_tool_handlers.py和backgroud_process_manager_web.py依赖BackgroundProcessManager的现有功能\n   - 重构不能破坏这些依赖关系\n\n### 实现策略\n\n1. **BackgroundProcess类增强**：\n   - 添加`__getattr__`方法：将未处理的属性和方法转发到内部process对象\n   - 实现`communicate`方法：与Process.communicate接口兼容，同时保持日志记录功能\n   - 实现或转发其他关键方法：`wait`、`terminate`、`kill`等\n   - 确保关键属性可访问：`returncode`、`pid`、`stdin/stdout/stderr`等\n\n2. **BackgroundProcessManager类增强**：\n   - 实现兼容的`create_process`方法：与ProcessManager相同的签名，内部调用现有功能\n   - 实现`execute_with_timeout`方法：处理进程执行和超时管理，复用现有功能\n   - 保持现有方法不变：确保与现有调用者兼容\n\n重构完成后，shell_executor.py应能通过不修改代码直接使用BackgroundProcessManager替代ProcessManager。"
    },
    {
      "id": "5c5099cd-1120-4078-a5a4-d49fa59c9307",
      "name": "实施测试和验证",
      "description": "运行测试用例验证重构后的代码，确保BackgroundProcessManager和BackgroundProcess类能够正确替代ProcessManager和Process类，且不破坏现有功能。",
      "status": "待處理",
      "dependencies": [
        {
          "taskId": "0ea5e298-4b79-47ae-ac6b-45b8d994d097"
        },
        {
          "taskId": "fbc88caa-33cc-47c5-a491-09afb5b47f38"
        },
        {
          "taskId": "31fdf49a-b0d4-4304-8921-9183722c7ba4"
        },
        {
          "taskId": "52c19588-ffbd-4327-bcb3-ff367cf3923d"
        }
      ],
      "createdAt": "2025-05-12T08:18:34.313Z",
      "updatedAt": "2025-05-12T08:18:34.313Z",
      "relatedFiles": [
        {
          "path": "tests/test_backgground_process_manager_compatability.py",
          "type": "REFERENCE",
          "description": "测试BackgroundProcessManager与ProcessManager兼容性的测试用例"
        },
        {
          "path": "tests/test_backgground_process_manager_compatability_macos.py",
          "type": "REFERENCE",
          "description": "测试BackgroundProcessManager在macOS上的功能的测试用例"
        }
      ],
      "implementationGuide": "1. 运行测试用例：\n```bash\nuv --project . run pytest tests/test_backgground_process_manager_compatability.py -v\n```\n\n2. 如果环境支持，也可以运行macOS特定测试：\n```bash\nuv --project . run pytest tests/test_backgground_process_manager_compatability_macos.py -v\n```\n\n3. 如果测试失败，根据错误信息进行调试和修复\n\n4. 确保重构不破坏现有功能，可以运行其他相关测试",
      "verificationCriteria": "1. 所有测试用例通过\n2. BackgroundProcess能够替代Process使用\n3. BackgroundProcessManager.create_process和execute_with_timeout方法正常工作\n4. 不破坏现有的BackgroundProcess和BackgroundProcessManager功能",
      "analysisResult": "## 技术分析\n\n### 现有代码分析\n\n1. **ProcessManager类分析**：\n   - `create_process` 方法：创建异步子进程，接受shell命令、工作目录、标准输入输出、环境变量等参数\n   - `execute_with_timeout` 方法：执行进程并支持超时，返回stdout和stderr\n   - 这些是shell_executor.py依赖的核心接口\n\n2. **BackgroundProcess类分析**：\n   - 当前是独立类，不是Process的子类或封装\n   - 包含对真实asyncio.subprocess.Process的引用\n   - 提供了丰富的日志记录和进程状态管理功能\n\n3. **BackgroundProcessManager类分析**：\n   - 具有自己的进程创建和管理方法\n   - 提供了额外的功能，如进程监控、输出记录等\n   - 缺少与ProcessManager完全兼容的方法签名\n\n4. **依赖分析**：\n   - bg_tool_handlers.py和backgroud_process_manager_web.py依赖BackgroundProcessManager的现有功能\n   - 重构不能破坏这些依赖关系\n\n### 实现策略\n\n1. **BackgroundProcess类增强**：\n   - 添加`__getattr__`方法：将未处理的属性和方法转发到内部process对象\n   - 实现`communicate`方法：与Process.communicate接口兼容，同时保持日志记录功能\n   - 实现或转发其他关键方法：`wait`、`terminate`、`kill`等\n   - 确保关键属性可访问：`returncode`、`pid`、`stdin/stdout/stderr`等\n\n2. **BackgroundProcessManager类增强**：\n   - 实现兼容的`create_process`方法：与ProcessManager相同的签名，内部调用现有功能\n   - 实现`execute_with_timeout`方法：处理进程执行和超时管理，复用现有功能\n   - 保持现有方法不变：确保与现有调用者兼容\n\n重构完成后，shell_executor.py应能通过不修改代码直接使用BackgroundProcessManager替代ProcessManager。"
    }
  ]
}